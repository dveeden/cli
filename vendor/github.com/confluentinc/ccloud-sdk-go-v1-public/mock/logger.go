// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: interfaces.go

package mock

import (
	sync "sync"
)

// Logger is a mock of Logger interface
type Logger struct {
	lockDebug sync.Mutex
	DebugFunc func(arg0 ...interface{})

	lockDebugf sync.Mutex
	DebugfFunc func(arg0 string, arg1 ...interface{})

	lockInfo sync.Mutex
	InfoFunc func(arg0 ...interface{})

	lockInfof sync.Mutex
	InfofFunc func(arg0 string, arg1 ...interface{})

	lockWarn sync.Mutex
	WarnFunc func(arg0 ...interface{})

	lockWarnf sync.Mutex
	WarnfFunc func(arg0 string, arg1 ...interface{})

	lockError sync.Mutex
	ErrorFunc func(arg0 ...interface{})

	lockErrorf sync.Mutex
	ErrorfFunc func(arg0 string, arg1 ...interface{})

	calls struct {
		Debug []struct {
			Arg0 []interface{}
		}
		Debugf []struct {
			Arg0 string
			Arg1 []interface{}
		}
		Info []struct {
			Arg0 []interface{}
		}
		Infof []struct {
			Arg0 string
			Arg1 []interface{}
		}
		Warn []struct {
			Arg0 []interface{}
		}
		Warnf []struct {
			Arg0 string
			Arg1 []interface{}
		}
		Error []struct {
			Arg0 []interface{}
		}
		Errorf []struct {
			Arg0 string
			Arg1 []interface{}
		}
	}
}

// Debug mocks base method by wrapping the associated func.
func (m *Logger) Debug(arg0 ...interface{}) {
	m.lockDebug.Lock()
	defer m.lockDebug.Unlock()

	if m.DebugFunc == nil {
		panic("mocker: Logger.DebugFunc is nil but Logger.Debug was called.")
	}

	call := struct {
		Arg0 []interface{}
	}{
		Arg0: arg0,
	}

	m.calls.Debug = append(m.calls.Debug, call)

	m.DebugFunc(arg0...)
}

// DebugCalled returns true if Debug was called at least once.
func (m *Logger) DebugCalled() bool {
	m.lockDebug.Lock()
	defer m.lockDebug.Unlock()

	return len(m.calls.Debug) > 0
}

// DebugCalls returns the calls made to Debug.
func (m *Logger) DebugCalls() []struct {
	Arg0 []interface{}
} {
	m.lockDebug.Lock()
	defer m.lockDebug.Unlock()

	return m.calls.Debug
}

// Debugf mocks base method by wrapping the associated func.
func (m *Logger) Debugf(arg0 string, arg1 ...interface{}) {
	m.lockDebugf.Lock()
	defer m.lockDebugf.Unlock()

	if m.DebugfFunc == nil {
		panic("mocker: Logger.DebugfFunc is nil but Logger.Debugf was called.")
	}

	call := struct {
		Arg0 string
		Arg1 []interface{}
	}{
		Arg0: arg0,
		Arg1: arg1,
	}

	m.calls.Debugf = append(m.calls.Debugf, call)

	m.DebugfFunc(arg0, arg1...)
}

// DebugfCalled returns true if Debugf was called at least once.
func (m *Logger) DebugfCalled() bool {
	m.lockDebugf.Lock()
	defer m.lockDebugf.Unlock()

	return len(m.calls.Debugf) > 0
}

// DebugfCalls returns the calls made to Debugf.
func (m *Logger) DebugfCalls() []struct {
	Arg0 string
	Arg1 []interface{}
} {
	m.lockDebugf.Lock()
	defer m.lockDebugf.Unlock()

	return m.calls.Debugf
}

// Info mocks base method by wrapping the associated func.
func (m *Logger) Info(arg0 ...interface{}) {
	m.lockInfo.Lock()
	defer m.lockInfo.Unlock()

	if m.InfoFunc == nil {
		panic("mocker: Logger.InfoFunc is nil but Logger.Info was called.")
	}

	call := struct {
		Arg0 []interface{}
	}{
		Arg0: arg0,
	}

	m.calls.Info = append(m.calls.Info, call)

	m.InfoFunc(arg0...)
}

// InfoCalled returns true if Info was called at least once.
func (m *Logger) InfoCalled() bool {
	m.lockInfo.Lock()
	defer m.lockInfo.Unlock()

	return len(m.calls.Info) > 0
}

// InfoCalls returns the calls made to Info.
func (m *Logger) InfoCalls() []struct {
	Arg0 []interface{}
} {
	m.lockInfo.Lock()
	defer m.lockInfo.Unlock()

	return m.calls.Info
}

// Infof mocks base method by wrapping the associated func.
func (m *Logger) Infof(arg0 string, arg1 ...interface{}) {
	m.lockInfof.Lock()
	defer m.lockInfof.Unlock()

	if m.InfofFunc == nil {
		panic("mocker: Logger.InfofFunc is nil but Logger.Infof was called.")
	}

	call := struct {
		Arg0 string
		Arg1 []interface{}
	}{
		Arg0: arg0,
		Arg1: arg1,
	}

	m.calls.Infof = append(m.calls.Infof, call)

	m.InfofFunc(arg0, arg1...)
}

// InfofCalled returns true if Infof was called at least once.
func (m *Logger) InfofCalled() bool {
	m.lockInfof.Lock()
	defer m.lockInfof.Unlock()

	return len(m.calls.Infof) > 0
}

// InfofCalls returns the calls made to Infof.
func (m *Logger) InfofCalls() []struct {
	Arg0 string
	Arg1 []interface{}
} {
	m.lockInfof.Lock()
	defer m.lockInfof.Unlock()

	return m.calls.Infof
}

// Warn mocks base method by wrapping the associated func.
func (m *Logger) Warn(arg0 ...interface{}) {
	m.lockWarn.Lock()
	defer m.lockWarn.Unlock()

	if m.WarnFunc == nil {
		panic("mocker: Logger.WarnFunc is nil but Logger.Warn was called.")
	}

	call := struct {
		Arg0 []interface{}
	}{
		Arg0: arg0,
	}

	m.calls.Warn = append(m.calls.Warn, call)

	m.WarnFunc(arg0...)
}

// WarnCalled returns true if Warn was called at least once.
func (m *Logger) WarnCalled() bool {
	m.lockWarn.Lock()
	defer m.lockWarn.Unlock()

	return len(m.calls.Warn) > 0
}

// WarnCalls returns the calls made to Warn.
func (m *Logger) WarnCalls() []struct {
	Arg0 []interface{}
} {
	m.lockWarn.Lock()
	defer m.lockWarn.Unlock()

	return m.calls.Warn
}

// Warnf mocks base method by wrapping the associated func.
func (m *Logger) Warnf(arg0 string, arg1 ...interface{}) {
	m.lockWarnf.Lock()
	defer m.lockWarnf.Unlock()

	if m.WarnfFunc == nil {
		panic("mocker: Logger.WarnfFunc is nil but Logger.Warnf was called.")
	}

	call := struct {
		Arg0 string
		Arg1 []interface{}
	}{
		Arg0: arg0,
		Arg1: arg1,
	}

	m.calls.Warnf = append(m.calls.Warnf, call)

	m.WarnfFunc(arg0, arg1...)
}

// WarnfCalled returns true if Warnf was called at least once.
func (m *Logger) WarnfCalled() bool {
	m.lockWarnf.Lock()
	defer m.lockWarnf.Unlock()

	return len(m.calls.Warnf) > 0
}

// WarnfCalls returns the calls made to Warnf.
func (m *Logger) WarnfCalls() []struct {
	Arg0 string
	Arg1 []interface{}
} {
	m.lockWarnf.Lock()
	defer m.lockWarnf.Unlock()

	return m.calls.Warnf
}

// Error mocks base method by wrapping the associated func.
func (m *Logger) Error(arg0 ...interface{}) {
	m.lockError.Lock()
	defer m.lockError.Unlock()

	if m.ErrorFunc == nil {
		panic("mocker: Logger.ErrorFunc is nil but Logger.Error was called.")
	}

	call := struct {
		Arg0 []interface{}
	}{
		Arg0: arg0,
	}

	m.calls.Error = append(m.calls.Error, call)

	m.ErrorFunc(arg0...)
}

// ErrorCalled returns true if Error was called at least once.
func (m *Logger) ErrorCalled() bool {
	m.lockError.Lock()
	defer m.lockError.Unlock()

	return len(m.calls.Error) > 0
}

// ErrorCalls returns the calls made to Error.
func (m *Logger) ErrorCalls() []struct {
	Arg0 []interface{}
} {
	m.lockError.Lock()
	defer m.lockError.Unlock()

	return m.calls.Error
}

// Errorf mocks base method by wrapping the associated func.
func (m *Logger) Errorf(arg0 string, arg1 ...interface{}) {
	m.lockErrorf.Lock()
	defer m.lockErrorf.Unlock()

	if m.ErrorfFunc == nil {
		panic("mocker: Logger.ErrorfFunc is nil but Logger.Errorf was called.")
	}

	call := struct {
		Arg0 string
		Arg1 []interface{}
	}{
		Arg0: arg0,
		Arg1: arg1,
	}

	m.calls.Errorf = append(m.calls.Errorf, call)

	m.ErrorfFunc(arg0, arg1...)
}

// ErrorfCalled returns true if Errorf was called at least once.
func (m *Logger) ErrorfCalled() bool {
	m.lockErrorf.Lock()
	defer m.lockErrorf.Unlock()

	return len(m.calls.Errorf) > 0
}

// ErrorfCalls returns the calls made to Errorf.
func (m *Logger) ErrorfCalls() []struct {
	Arg0 string
	Arg1 []interface{}
} {
	m.lockErrorf.Lock()
	defer m.lockErrorf.Unlock()

	return m.calls.Errorf
}

// Reset resets the calls made to the mocked methods.
func (m *Logger) Reset() {
	m.lockDebug.Lock()
	m.calls.Debug = nil
	m.lockDebug.Unlock()
	m.lockDebugf.Lock()
	m.calls.Debugf = nil
	m.lockDebugf.Unlock()
	m.lockInfo.Lock()
	m.calls.Info = nil
	m.lockInfo.Unlock()
	m.lockInfof.Lock()
	m.calls.Infof = nil
	m.lockInfof.Unlock()
	m.lockWarn.Lock()
	m.calls.Warn = nil
	m.lockWarn.Unlock()
	m.lockWarnf.Lock()
	m.calls.Warnf = nil
	m.lockWarnf.Unlock()
	m.lockError.Lock()
	m.calls.Error = nil
	m.lockError.Unlock()
	m.lockErrorf.Lock()
	m.calls.Errorf = nil
	m.lockErrorf.Unlock()
}
